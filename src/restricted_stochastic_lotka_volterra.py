""" Contains modules for executing Monte Carlo simulation of the restricted stochastic
    Lotka-Volterra system. A single Monte Carlo step corresponds to selecting all 
    individuals (cells/sites) on average, i.e. a single Monte Carlo step corresponds 
    to randomly selecting K sites and evolving them accordingly. Here, K is the number
    of occupied sites at time t. Foragers undergo (cardinal) Levy walks with constant 
    velocity equal to the difference between lattice sites, normalized to 1. Prey is 
    initially distributed on lattice sites generated by binary selection of 
    two-dimensional fractional Brownian motion. Predators are initially distributed 
    uniformly on empty sites initially not occupied by prey. 

    Most modules are implemented using Numba for speed purposes. Numba modules 
    are identified by the header @numba.jit(nopython=True), and they are cached 
    (cache=True). Hence, while the initial run wherein these modules need to be 
    compiled might be a bit slow(er), subsequent calls should be much faster.
"""
# Import necessary libraries
from numba.core.errors import new_error_context
import numpy as np 
from collections import deque
import numba 
# Import modules
import src.lattice

###################
# Numba functions #
# --------------- #
# General functions
@numba.jit(nopython=True, cache=True)
def nb_set_seed(seed):
    """ Specifically call the seed from Numba code, as calling numpy.random.seed()
        from non-Numba code (or from object mode code) will seed the Numpy random 
        generator, not the Numba random generator.
    """
    np.random.seed(seed)

@numba.jit(nopython=True, cache=True)
def nb_sample_cdf(cdf):
    """ Generate sample from given (discrete) cdf """
    rand = np.random.random() 
    for i in range(len(cdf)):
        if rand < cdf[i]:
            return i + 1

# Specific functions
@numba.jit(nopython=True, cache=True)
def nb_truncated_zipf(alpha, N):
    """ Compute the cumulative distribution function for the truncated
        discrete zeta distribution (Zipf's law)
    """
    x = np.arange(1, N+1)
    weights = x ** -alpha
    weights /= np.sum(weights)
    cdf = np.cumsum(weights)
    return cdf

@numba.jit(nopython=True, cache=True)
def nb_get_1D_neighbors(idx, L):
    """ Get the 1D neighbors of a specific index, abiding periodic boundary conditions
        on the (original) 2D lattice
    """
    # Convert index to 2D index
    i, j = idx // L, idx % L 
    neighbors = [[(i+1)%L, j], [(i-1)%L,j], [i,(j+1)%L], [i,(j-1)%L]]
    neighbors_1D = [n[0]*L + n[1] for n in neighbors]
    return neighbors_1D

@numba.jit(nopython=True, cache=True)
def nb_SLLVM(T, N0, M0, sites, mu, lambda_, sigma, alpha, nmeasures):
    """ Runs the stochastic lattice Lotka-Volterra model
        While the lattice is a 2D (square) lattice, for speed we first convert everyting
        to a 1D lattice, where neighbors and periodic boundary conditions properly need
        to be taken into account.

        Parameters
        ----------
        T : np.int64
            The number of Monte Carlo time steps
        N0 : np.int64
            The initial number of predators (foragers)
        M0 : np.int64
            The initial number of prey (resources)
            Note that M0=min(M0,ρL²), where ρL² the number of sites eligible for prey
            If M0 = -1, then all eligible sites are initially filled with prey
        sites : np.array((L,L),dtype=np.int64)
            L x L numpy array of eligible sites for prey (1) and empty sites (0)
        mu : np.float64
            Mortality rate of the predators (foragers)
        lambda_ : np.float64
            Reproduction rate of the predators
        sigma : np.float64
            Reproduction rate of the prey (resources)
        alpha : np.float64
            Levy walk parameter of the predators' movement
        nmeasures : np.int64
            Number of times populations are measures at equally spaced intervals
    """
    L, _ = sites.shape 
    dmeas = T // nmeasures
    # Adapt some variables as they should take on a specific value if -1 is provided
    mu = 1 / L if mu == -1 else mu              # Death rate 
    N0 = L**2 // 10 if N0 == -1 else N0         # Initial number of predators
    alpha = np.inf if alpha == -1 else alpha    # Levy parameter

    ## Initialize constants
    delta_idx = [1, -1, L, -L]
    delta_idx_2D = [[0,1], [0,-1], [1,0], [-1,0]]
    # Compute cdf for Zipf's law as the discrete (truncated) inverse power law
    _cdf = nb_truncated_zipf(alpha, L)

    ## Convert the eligible sites to 1D array
    sites = sites.flatten()
    ## Initialize the 1-dimensional lattices
    #  We need two lattices:
    #  * one lattice of integer type that contains the IDs of the predators
    #  * one lattice of boolean type that contains prey
    pred_lattice = np.zeros(L*L, dtype=np.int64)
    prey_lattice = np.zeros(L*L, dtype=np.bool_)

    ## Distribute prey on eligible sites
    prey_sites = np.where(sites==1)[0]
    M0 = min(M0, len(prey_sites))
    if M0 == -1:
        M0 = 2*N0 if len(prey_sites)==L**2 else len(prey_sites)
    prey_idxs = np.random.choice(prey_sites, size=M0, replace=False)
    for i in prey_idxs:
        prey_lattice[i] = True 
    ## Distribute predators on sites that do not contain prey
    pred_sites = np.flatnonzero(~prey_lattice)
    pred_idxs = np.random.choice(pred_sites, size=N0, replace=False)
    for pred_idx, lattice_idx in enumerate(pred_idxs):
        # Predator lattice contains the IDs, and needs to be offset by 1 as to
        # not have ID 0, as 0 represents no predator on that position
        pred_lattice[lattice_idx] = pred_idx + 1

    ## Compute list that contains indices (positions) of occupied sites
    occupied_sites = [idx for idx in prey_idxs] + [idx for idx in pred_idxs]
    ## Allocate lists needed for individual predator behavior
    gen = range(N0)
    flight_length = [i for i in gen]    # Sampled flight length of individual predators
    curr_length = [0 for i in gen]      # Current path length of individual predators
    didx = [0 for i in gen]             # Current direction of individual predators
    current_max_id = N0 + 1

    ## Initialize number of predators and prey
    N = N0 
    M = M0 
    K = N0 + M0

    ## Allocate arrays for storing measures
    prey_population = np.zeros(nmeasures+1, dtype=np.int64)
    pred_population = np.zeros(nmeasures+1, dtype=np.int64)
    coexistence = 1
    # lattice_configuration = np.zeros((L*L, nmeasures+1), dtype=np.int64)    
    # Store initial values
    prey_population[0] = M0 
    pred_population[0] = N0 
    # lattice_configuration[prey_lattice,0] = -1 
    # lattice_configuration[pred_lattice>0,0] = 1

    ##############################################
    ## Run the stochastic Lotka-Volterra system ##
    for t in range(1,T+1):
        print(N, M, K)
        ## Store desired variables every dmeas timesteps
        if t % dmeas == 0:
            imeas = t // dmeas
            prey_population[imeas] = M 
            pred_population[imeas] = N
            # lattice_configuration[prey_lattice,imeas] = -1 
            # lattice_configuration[pred_lattice>0,imeas] = 1

        ## Stop the simulation if:
        # prey goes extinct, as predators will also go extinct
        if M == 0:
            coexistence = 0
            break
        # predators go extinct, as prey will fully occupy all sites
        if N == 0:
            coexistence = 0
            prey_population[imeas:] = L**2 
            break 
        
        ## Select random occupied sites        
        for tau in range(K):
            # Select a random occupied site
            _k = np.random.randint(0, K)
            # print(_k, K, len(occupied_sites), pred_lattice)
            idx = occupied_sites[_k]
            neighbors = nb_get_1D_neighbors(idx, L)
            ## If the site contains prey, reproduce with probability (rate) σ
            #NOTE: Prey only reproduces if it has an empty neighboring site
            if prey_lattice[idx]:
                # Check if neighboring sites are empty
                empty_neighbors = [
                    n for n in neighbors if sites[n] and (prey_lattice[n]==0 and pred_lattice[n]==0)
                ]
                _nempty = len(empty_neighbors)
                # Check if prey site is surrounded by other prey
                eligible_neighbors = [n for n in neighbors if sites[n] and not prey_lattice[n]]
                _neligible = len(eligible_neighbors)
                ## If there are empty neighboring sites, reproduce with rate σ
                if _nempty > 0:
                    # Randomly sample one of the eligible neighboring sites
                    neighbor = empty_neighbors[np.random.randint(0,_nempty)]
                    # Place prey there with probability σ
                    if np.random.random() < sigma:
                        prey_lattice[neighbor] = True       # Place prey on prey lattice
                        occupied_sites.append(neighbor)     # Append occupied site to the list
                        M += 1
                        K += 1
                ## If it is surrounded, remove it from the occupied sites
                # (NOTE that even though the site is still occupied, we should not take
                # it into account in our main loop as prey cannot reproduce)
                elif _neligible == 0:                    
                    occupied_sites[_k], occupied_sites[-1] = occupied_sites[-1], occupied_sites[_k]
                    del occupied_sites[-1]
                    K -= 1
                else:
                    pass
            ## If the site contains a predator, check in order
            # (i)   die with mortality rate μ
            # (ii)  start a new flight
            # (iii) continue the current flight
            # (iv)  consume prey and reproduce
            elif pred_lattice[idx] > 0:
                ## Get predator ID from the predator lattice
                _pred_id = pred_lattice[idx] - 1
                ## (i) die with mortality rate μ
                if np.random.random() < mu:
                    pred_lattice[idx] = 0           # Remove predator from predator lattice
                    occupied_sites[_k], occupied_sites[-1] = occupied_sites[-1], occupied_sites[_k]
                    del occupied_sites[-1]
                    N -= 1
                    K -= 1
                else:
                    ## (ii) start a new flight
                    if curr_length[_pred_id] == 0:
                        flight_length[_pred_id] = nb_sample_cdf(_cdf)
                        didx[_pred_id] = np.random.randint(0,4)
                    
                    ## (iii) continue the current (or just started) flight
                    # Determine new 1D index using periodic boundary conditions
                    _i = ( idx // L + delta_idx_2D[didx[_pred_id]][0] ) % L
                    _j = ( idx %  L + delta_idx_2D[didx[_pred_id]][1] ) % L 
                    new_idx = _i * L + _j
                    # Ensure single occupancy by doing nothing when the site is
                    # already occupied by a predator or predators
                    if pred_lattice[new_idx] > 0:
                        curr_length[_pred_id] = 0       # Truncate current flight
                    else:
                        # Increment current path length
                        curr_length[_pred_id] += 1
                        # End current flight if current path length exceeds sampled length
                        if curr_length[_pred_id] > flight_length[_pred_id]:
                            curr_length[_pred_id] = 0 

                        ## (iv) consume prey and reproduce
                        if prey_lattice[new_idx]:
                            prey_lattice[new_idx] = False   # Remove prey from that site
                            curr_length[_pred_id] = 0       # Truncate current flight
                            M -= 1
                            
                            ## Reproduce onto the site with rate λ
                            if np.random.random() < lambda_:
                                pred_lattice[new_idx] = current_max_id
                                flight_length.append(0)
                                curr_length.append(0)
                                didx.append(0)
                                current_max_id += 1
                                N += 1
                            else:
                                # Remove the site previously occupied by the predator
                                occupied_sites[_k], occupied_sites[-1] = occupied_sites[-1], occupied_sites[_k]
                                del occupied_sites[-1]
                                K -= 1
                                # Update the predator lattice 
                                pred_lattice[new_idx] = pred_lattice[idx]
                                pred_lattice[idx] = 0
                            # If the site was previously occupied, but was not included
                            # in the occupied sites as the prey was surrounded by prey
                            # on all sides (see above), add the now again occupied site
                            if new_idx not in occupied_sites:
                                occupied_sites.append(new_idx)
                                K += 1
                        else:
                            ## Displace
                            pred_lattice[new_idx] = pred_lattice[idx]
                            pred_lattice[idx] = 0 
                            occupied_sites[_k] = new_idx
            # else:
            #     print(t, tau, idx, "nothing"); exit()
    return prey_population, pred_population, coexistence

#################################
# Wrapper for the numba modules #
class SLLVM(object):
    """ Class for the Stochastic Lattice Lotka-Volterra Model """
    def __init__(self) -> None: 
        self.Lattice = src.lattice.Lattice()

    def run_system(self, args):
        # Fix the RNG
        np.random.seed(args.seed)
        nb_set_seed(args.seed)
        # Compute the prey (resource) sites on the L x L lattice
        if args.rho == 1:
            sites = np.ones((2**args.m, 2**args.m), dtype=np.int64)
        else:
            _lattice = self.Lattice.SpectralSynthesis2D(2**args.m, args.H)
            sites = self.Lattice.binary_lattice(_lattice, args.rho)
        # Initialize dictionary
        outdict = {}
        # Run 
        output = nb_SLLVM(
            args.T, args.N0, args.M0, sites, 
            args.mu, args.lambda_, args.sigma, args.alpha,
            args.nmeasures
        )
        # Save
        outdict['prey_population'] = output[0]
        outdict['pred_population'] = output[1]
        outdict['coexistence'] = output[2]
        return outdict

    
