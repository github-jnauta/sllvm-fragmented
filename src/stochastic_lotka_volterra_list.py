""" Contains modules for executing Monte Carlo simulation of the stochastic
    Lotka-Volterra system. A single Monte Carlo step corresponds to selecting
    all individuals (cells/sites) on average, i.e. a single Monte Carlo step
    corresponds to randomly selecting L*L sites and evolving them accordingly.
    Foragers undergo (cardinal) Levy walks with constant velocity equal to the
    difference between lattice sites, normalized to 1. 
    Prey is initially distributed on lattice sites generated by binary selection
    of two-dimensional fractional Brownian motion. Predators are initially
    distributed uniformly on empty sites. 

    Most modules are implemented using numba for speed purposes. Numba modules 
    are identified by the header @numba.jit(), and are cached (cache=True). Hence,
    while the initial run wherein these modules need to be compiled might be a bit
    slow(er), subsequent calls should be much faster.
"""
# Import necessary libraries
import numpy as np 
import numba 
from numba.typed import List 
# Import modules
import src.lattice

###################
# Numba functions #
# --------------- #
# General functions
@numba.jit(nopython=True, cache=True)
def nb_set_seed(seed):
    np.random.seed(seed)

@numba.jit(nopython=True, cache=True)
def nb_sample_cdf(cdf):
    """ Generate sample from given (discrete) cdf """
    rand = np.random.random() 
    for i in range(len(cdf)):
        if rand < cdf[i]:
            return i + 1

# Specific functions
@numba.jit(nopython=True, cache=True)
def nb_truncated_zipf(alpha, N):
    """ Compute the cumulative distribution function for the truncated
        discrete zeta distribution (Zipf's law)
    """
    x = np.arange(1, N+1)
    weights = x ** -alpha
    weights /= np.sum(weights)
    _cdf = np.cumsum(weights)
    cdf = List()
    [cdf.append(p) for p in _cdf]
    return cdf

@numba.jit(nopython=True, cache=True)
def nb_get_1D_neighbors(idx, L):
    """ Get the 1D neighbors of a specific index, abiding periodic boundary conditions
        on the (original) 2D lattice
    """
    # Convert index to 2D index
    i, j = idx // L, idx % L 
    neighbors = np.array([
        [(i+1)%L, j], [(i-1)%L,j], [i,(j+1)%L], [i,(j-1)%L]
    ], dtype=np.int64)
    neighbors_1D = np.array([n[0]*L + n[1] for n in neighbors], dtype=np.int64)
    return neighbors_1D

@numba.jit(nopython=True, cache=True)
def nb_SLLVM(T, N0, M0, sites, mu, lambda_, sigma, alpha, nmeasures):
    """ Runs the stochastic lattice Lotka-Volterra model
        While the lattice is a 2D (square) lattice, for speed we first convert everyting
        to a 1D lattice, where neighbors and periodic boundary conditions properly need
        to be taken into account. The 1-dimensional index of the lattice is conveniently
        also the position on the lattice, as sites are restricted to the lattice. 

        Parameters
        ----------
        T : np.int64
            The number of Monte Carlo time steps
        N0 : np.int64
            The initial number of predators (foragers)
        M0 : np.int64
            The initial number of prey (resources)
            Note that M0=min(M0,ρL²), where ρL² the number of sites eligible for prey
            If M0 = -1, then all eligible sites are initially filled with prey
        sites : np.array((L,L),dtype=np.int64)
            L x L numpy array of eligible sites for prey (1) and empty sites (0)
        mu : np.float64
            Mortality rate of the predators (foragers)
        lambda_ : np.float64
            Reproduction rate of the predators
        sigma : np.float64
            Reproduction rate of the prey (resources)
        alpha : np.float64
            Levy walk parameter of the predators' movement
        nmeasures : np.int64
            Number of times populations are measures at equally spaced intervals
    """
    L, _ = sites.shape 
    dmeas = T // nmeasures
    ## Initialize constants
    delta_idx = np.array([1, -1, L, -L], dtype=np.int64)
    delta_idx_2D = np.array([[0,1], [0,-1], [1,0], [-1,0]], dtype=np.int64)
    # Compute cdf for Zipf's law as the discrete (truncated) power law distribution
    _cdf = nb_truncated_zipf(alpha, L)
    ## Convert the eligible sites to 1D array
    sites = sites.flatten()
    ## Initialize the 1D lattice
    #  Each site on the lattice can contain three states:
    #   -1  : prey (resource)
    #   >=1 : predator (forager) [multiple occupancy is allowed (for now)]
    lattice = np.zeros(L*L, dtype=np.int64)
    # Initialize predators on sites not eligible for prey
    N0 = L**2 // 10 if N0 == -1 else N0 
    predator_sites = np.where(sites==0)[0]
    predator_idxs = np.random.choice(predator_sites, size=N0, replace=False)
    for i in predator_idxs:
        lattice[i] = 1
    # Initialize prey on eligible sites
    prey_sites = np.where(sites==1)[0]
    M0 = min(M0, len(prey_sites))
    M0 = len(prey_sites) if M0 == -1 else M0
    prey_idxs = np.random.choice(prey_sites, size=M0, replace=False)
    for i in prey_idxs:
        lattice[i] = -1   
    ## Compute occupied sites and its mask
    occupied_sites_arr = np.where(lattice!=0)[0]
    occupied_sites = List()
    occupied_mask = List()
    for i in range(M0+N0):
        occupied_sites.append(occupied_sites_arr[i])
        occupied_mask.append(True)

    ## Allocate
    predator_ids = List()
    didx = List()
    flight_length = List()
    curr_length = List()
    predator_pos = List()
    alive_mask = List()
    for i in range(N0):
        predator_ids.append(i)                  # ID of each predator
        didx.append(0)                          # 1D direction for current Levy bout
        flight_length.append(0)                 # Sampled flight length of each predator
        curr_length.append(0)                   # Current traversed length of the fligh
        predator_pos.append(predator_idxs[i])   # Current position (index) of predator
        alive_mask.append(True)                 # Boolean mask indicating predator is alive
    current_max_id = N0 - 1                     # Specify current maximum ID
    # Get predator positions seperately as is necessary for simulating Levy walks
    # [predator_pos.append(i) for i in predator_idxs]    
    # Initialize number of predators and prey
    N = N0 
    M = M0 
    K = N0 + M0
    # Specify temporary variables
    temp_N = N

    ## Allocate arrays for storing measures
    prey_population = np.zeros(nmeasures+1, dtype=np.int64)
    pred_population = np.zeros(nmeasures+1, dtype=np.int64)
    coexistence = 1
    # lattice_configuration = np.zeros((L*L, nmeasures+1), dtype=np.int64)
    # predator_positions = np.zeros((N0,T), dtype=np.int64)
    # Store initial values
    prey_population[0] = M0 
    pred_population[0] = N0 
    # lattice_configuration[:,0] = lattice.copy()

    ## Run the stochastic Lotka-Volterra system
    for t in range(1,T+1):
        ## Store desired variables every dmeas timesteps
        if t % dmeas == 0:
            imeas = t // dmeas
            prey_population[imeas] = M 
            pred_population[imeas] = N
            # lattice_configuration[:,imeas] = lattice.copy()
        
        ## Stop the simulation if:
        # prey goes extinct, as predators will also go extinct
        if M == 0:
            coexistence = 0
            break
        # predators go extinct, as prey will fully occupy all sites
        if N == 0:
            coexistence = 0
            prey_population[imeas:] = L**2 
            break

        ## Remove all predators that are not alive anymore
        # (NOTE: Only do this if the number of predators has changed)
        if temp_N != N:
            # Create the generator
            _gen = range(len(alive_mask))
            # Change predator related lists
            predator_ids = List([predator_ids[i] for i in _gen if alive_mask[i]])
            didx = List([didx[i] for i in _gen if alive_mask[i]])
            flight_length = List([flight_length[i] for i in _gen if alive_mask[i]])
            curr_length = List([curr_length[i] for i in _gen if alive_mask[i]])
            predator_pos = List([predator_pos[i] for i in _gen if alive_mask[i]])
            alive_mask = List([alive_mask[i] for i in _gen if alive_mask[i]])
            temp_N = N 
            # Change occupance related list
            _ogen = range(len(occupied_mask))
            occupied_sites = List([occupied_sites[i] for i in _ogen if occupied_mask[i]])
            occupied_mask = List([occupied_mask[i] for i in _ogen if occupied_mask[i]])

        # Randomly select K sites in a loop, as a single loop that selects (on average)
        # each occupied site once is considered a single Monte Carlo time step
        steps = K 
        for tau in range(steps):
            # Select a random occupied site
            _k = np.random.randint(0, K)
            idx = occupied_sites[_k]
            neighbors = nb_get_1D_neighbors(idx, L)
            ## If the site contains prey, reproduce with probability (rate) σ
            # (NOTE: Prey only reproduces if it has an empty neighboring site)
            if lattice[idx] == -1:
                # Check if neighboring sites are empty
                eligible_neighbors = List([n for n in neighbors if not lattice[n]])
                _nn = len(eligible_neighbors)
                if _nn > 0:
                    # Randomly sample one of the eligible neighboring sites
                    neighbor = eligible_neighbors[np.random.randint(0,_nn)]
                    # Place prey there with probability σ
                    if np.random.random() < sigma:
                        lattice[neighbor] = -1
                        occupied_sites.append(neighbor)
                        occupied_mask.append(True)
                        M += 1
                        K += 1
            ## If the site contains a predator, check in order
            # (i)   die with mortality rate μ
            # (ii)  start a new flight
            # (iii) continue the current flight
            # (iv)  consume prey and reproduce
            elif lattice[idx] > 0:
                ## Get predator ID. If two on the same location, select one
                for _pred_id, _pred_idx in enumerate(predator_pos):
                    if _pred_idx == idx and alive_mask[_pred_id]:
                        break
                else:
                    continue 
                ## (i) Die with mortality rate μ
                #NOTE: We can substract 1, such that if the current state is the reproductive
                #      state with value 2, there is 1 predator still remaining
                if np.random.random() < mu:
                    lattice[idx] -= 1
                    # Change the alive_mask of the predator to False
                    alive_mask[_pred_id] = False 
                    N -= 1
                    # Change occupied mask of site to false if no predator remains
                    if lattice[idx] == 0:
                        occupied_mask[_k] = False 
                        K -= 1
                else:
                    ## (ii) start a new flight
                    if curr_length[_pred_id] == 0:
                        flight_length[_pred_id] = nb_sample_cdf(_cdf)
                        didx[_pred_id] = np.random.randint(0,4)
                    
                    ## (iii) continue the current (or just started) flight
                    # Update position
                    # NOTE: The lattice is updated below (iv)
                    lattice[idx] -= 1
                    # Determine new 1D index using periodic boundary conditions
                    _i = ( idx // L + delta_idx_2D[didx[_pred_id]][0] ) % L
                    _j = ( idx % L + delta_idx_2D[didx[_pred_id]][1] ) % L 
                    new_idx = _i * L + _j
                    # Ensure single occupancy
                    if lattice[new_idx] > 0:
                        curr_length[_pred_id] = 0       # Truncate current flight
                        continue
                    else:                        
                        curr_length[_pred_id] += 1      # Increment current path length
                    # Update predator position
                    predator_pos[_pred_id] = new_idx
                    # End current flight if path length exceeds the sampled length
                    if curr_length[_pred_id] > flight_length[_pred_id]:
                        curr_length[_pred_id] = 0 

                    if lattice[new_idx] == -1:
                        ## (iv) consume prey and reproduce
                        # TODO: MAKE SURE THIS IS CORRECT
                        lattice[new_idx] = 1            # Site becomes occupied by predator
                        curr_length[_pred_id] = 0       # Truncate current flight
                        occupied_sites[_k] = new_idx    # Update index occupied by predator
                        M -= 1
                        # occupied_sites = np.delete(occupied_sites, __k)
                        # occupied_sites.pop(__k)
                        # K = max(0, K-1)
                        ## Reproduce with rate λ
                        if np.random.random() < lambda_:
                            lattice[new_idx] += 1
                            predator_ids.append(current_max_id)
                            predator_pos.append(new_idx)
                            flight_length.append(0)
                            curr_length.append(0)
                            didx.append(0)
                            alive_mask.append(True)
                            current_max_id += 1
                            N += 1
                    else:
                        # NOTE: Update lattice as mentioned above
                        # No prey, so predator just moves there
                        lattice[new_idx] += 1
                        # Update site index occupied by the predator
                        occupied_sites[_k] = new_idx
    return prey_population, pred_population, coexistence

#################################
# Wrapper for the numba modules #
class SLLVM(object):
    """ Class for the Stochastic Lattice Lotka-Volterra Model """
    def __init__(self) -> None: 
        self.Lattice = src.lattice.Lattice()

    def run_system(self, args):
        # Fix the RNG
        np.random.seed(args.seed)
        nb_set_seed(args.seed)
        # Compute the prey (resource) sites on the L x L lattice
        _lattice = self.Lattice.SpectralSynthesis2D(2**args.m, args.H)
        sites = self.Lattice.binary_lattice(_lattice, args.rho)
        # Initialize dictionary
        outdict = {}
        outdict['prey_population'] = np.zeros((args.nmeasures+1, args.reps), dtype=np.int64)
        outdict['pred_population'] = np.zeros((args.nmeasures+1, args.reps), dtype=np.int64)
        outdict['coexistence'] = np.zeros(args.reps, dtype=np.int64)
        # Repeat the SLLVM for the lattice and gather results
        for rep in range(args.reps):
            output = nb_SLLVM(
                args.T, args.N0, args.M0, sites, 
                args.mu, args.lambda_, args.sigma, args.alpha,
                args.nmeasures
            )
            outdict['prey_population'][:,rep] = output[0]
            outdict['pred_population'][:,rep] = output[1]
            outdict['coexistence'][rep] = output[2]
        # outdict['lattice'] = output[3]
        return outdict

    
